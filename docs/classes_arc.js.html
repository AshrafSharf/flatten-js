<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>classes/arc.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Flatten.Arc.html">Arc</a><ul class='methods'><li data-type='method'><a href="Flatten.Arc.html#breakToFunctional">breakToFunctional</a></li><li data-type='method'><a href="Flatten.Arc.html#clone">clone</a></li><li data-type='method'><a href="Flatten.Arc.html#contains">contains</a></li><li data-type='method'><a href="Flatten.Arc.html#intersect">intersect</a></li><li data-type='method'><a href="Flatten.Arc.html#oldbox">oldbox</a></li><li data-type='method'><a href="Flatten.Arc.html#svg">svg</a></li><li data-type='method'><a href="Flatten.Arc.html#tangentInEnd">tangentInEnd</a></li><li data-type='method'><a href="Flatten.Arc.html#tangentInStart">tangentInStart</a></li></ul></li><li><a href="Flatten.Box.html">Box</a><ul class='methods'><li data-type='method'><a href="Flatten.Box.html#clone">clone</a></li><li data-type='method'><a href="Flatten.Box.html#equal_to">equal_to</a></li><li data-type='method'><a href="Flatten.Box.html#intersect">intersect</a></li><li data-type='method'><a href="Flatten.Box.html#less_than">less_than</a></li><li data-type='method'><a href="Flatten.Box.html#merge">merge</a></li><li data-type='method'><a href="Flatten.Box.html#notIntersect">notIntersect</a></li></ul></li><li><a href="Flatten.Circle.html">Circle</a><ul class='methods'><li data-type='method'><a href="Flatten.Circle.html#clone">clone</a></li><li data-type='method'><a href="Flatten.Circle.html#contains">contains</a></li><li data-type='method'><a href="Flatten.Circle.html#intersect">intersect</a></li><li data-type='method'><a href="Flatten.Circle.html#svg">svg</a></li><li data-type='method'><a href="Flatten.Circle.html#toArc">toArc</a></li></ul></li><li><a href="Flatten.Edge.html">Edge</a><ul class='methods'><li data-type='method'><a href="Flatten.Edge.html#contains">contains</a></li></ul></li><li><a href="Flatten.Face.html">Face</a><ul class='methods'><li data-type='method'><a href="Flatten.Face.html#area">area</a></li><li data-type='method'><a href="Flatten.Face.html#getBox">getBox</a></li></ul></li><li><a href="Flatten.Line.html">Line</a><ul class='methods'><li data-type='method'><a href="Flatten.Line.html#clone">clone</a></li><li data-type='method'><a href="Flatten.Line.html#contains">contains</a></li><li data-type='method'><a href="Flatten.Line.html#incidentTo">incidentTo</a></li><li data-type='method'><a href="Flatten.Line.html#intersect">intersect</a></li><li data-type='method'><a href="Flatten.Line.html#parallelTo">parallelTo</a></li></ul></li><li><a href="Flatten.PlanarSet.html">PlanarSet</a><ul class='methods'><li data-type='method'><a href="Flatten.PlanarSet.html#add">add</a></li><li data-type='method'><a href="Flatten.PlanarSet.html#delete">delete</a></li><li data-type='method'><a href="Flatten.PlanarSet.html#hit">hit</a></li><li data-type='method'><a href="Flatten.PlanarSet.html#search">search</a></li><li data-type='method'><a href="Flatten.PlanarSet.html#svg">svg</a></li></ul></li><li><a href="Flatten.Point.html">Point</a><ul class='methods'><li data-type='method'><a href="Flatten.Point.html#clone">clone</a></li><li data-type='method'><a href="Flatten.Point.html#distanceTo">distanceTo</a></li><li data-type='method'><a href="Flatten.Point.html#equalTo">equalTo</a></li><li data-type='method'><a href="Flatten.Point.html#leftTo">leftTo</a></li><li data-type='method'><a href="Flatten.Point.html#lessThan">lessThan</a></li><li data-type='method'><a href="Flatten.Point.html#on">on</a></li><li data-type='method'><a href="Flatten.Point.html#projectionOn">projectionOn</a></li><li data-type='method'><a href="Flatten.Point.html#rotate">rotate</a></li><li data-type='method'><a href="Flatten.Point.html#svg">svg</a></li><li data-type='method'><a href="Flatten.Point.html#translate">translate</a></li></ul></li><li><a href="Flatten.Polygon.html">Polygon</a><ul class='methods'><li data-type='method'><a href="Flatten.Polygon.html#addFace">addFace</a></li><li data-type='method'><a href="Flatten.Polygon.html#area">area</a></li><li data-type='method'><a href="Flatten.Polygon.html#clone">clone</a></li><li data-type='method'><a href="Flatten.Polygon.html#contains">contains</a></li><li data-type='method'><a href="Flatten.Polygon.html#deleteFace">deleteFace</a></li><li data-type='method'><a href="Flatten.Polygon.html#svg">svg</a></li></ul></li><li><a href="Flatten.Ray.html">Ray</a><ul class='methods'><li data-type='method'><a href="Flatten.Ray.html#clone">clone</a></li><li data-type='method'><a href="Flatten.Ray.html#intersect">intersect</a></li></ul></li><li><a href="Flatten.Segment.html">Segment</a><ul class='methods'><li data-type='method'><a href="Flatten.Segment.html#clone">clone</a></li><li data-type='method'><a href="Flatten.Segment.html#contains">contains</a></li><li data-type='method'><a href="Flatten.Segment.html#intersect">intersect</a></li><li data-type='method'><a href="Flatten.Segment.html#svg">svg</a></li><li data-type='method'><a href="Flatten.Segment.html#tangentInEnd">tangentInEnd</a></li><li data-type='method'><a href="Flatten.Segment.html#tangentInStart">tangentInStart</a></li></ul></li><li><a href="Flatten.Vector.html">Vector</a><ul class='methods'><li data-type='method'><a href="Flatten.Vector.html#clone">clone</a></li><li data-type='method'><a href="Flatten.Vector.html#cross">cross</a></li><li data-type='method'><a href="Flatten.Vector.html#dot">dot</a></li><li data-type='method'><a href="Flatten.Vector.html#equalTo">equalTo</a></li><li data-type='method'><a href="Flatten.Vector.html#invert">invert</a></li><li data-type='method'><a href="Flatten.Vector.html#multiply">multiply</a></li><li data-type='method'><a href="Flatten.Vector.html#normalize">normalize</a></li><li data-type='method'><a href="Flatten.Vector.html#rotate">rotate</a></li><li data-type='method'><a href="Flatten.Vector.html#rotate90CCW">rotate90CCW</a></li><li data-type='method'><a href="Flatten.Vector.html#rotate90CW">rotate90CW</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">classes/arc.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Created by Alex Bol on 3/10/2017.
 */

"use strict";

module.exports = function(Flatten) {
    /**
     * Class representing a circlular arc
     * @type {Arc}
     */
    Flatten.Arc = class Arc {
        /**
         *
         * @param {Point} pc - arc center
         * @param {number} r - arc radius
         * @param {number} startAngle - start angle in radians from 0 to 2*PI
         * @param {number} endAngle - end angle in radians from 0 to 2*PI
         * @param counterClockwise - arc direction, true - clockwise, false - counter clockwise
         */
        constructor(pc=new Flatten.Point(), r=1, startAngle=0, endAngle=2*Math.PI, counterClockwise=true) {
            this.pc = pc.clone();
            this.r = r;
            this.startAngle = startAngle;
            this.endAngle = endAngle;
            this.counterClockwise = counterClockwise;
        }

        /**
         * Return new instance of arc
         * @returns {Arc}
         */
        clone() {
            return new Flatten.Arc(this.pc.clone(), this.r, this.startAngle, this.endAngle, this.counterClockwise);
        }

        /**
         * Get sweep angle in radians. Sweep angle is non-negative number from 0 to 2*PI
         * @returns {number}
         */
        get sweep() {
            if (Flatten.Utils.EQ(this.startAngle, this.endAngle))
                return 0.0;                    // or Flatten.PIx2 ? - no zero arcs
            if (Flatten.Utils.EQ(Math.abs(this.startAngle - this.endAngle), Flatten.PIx2)) {
                return Flatten.PIx2;
            }
            let sweep;
            if (this.counterClockwise) {
                sweep = Flatten.Utils.GT(this.endAngle, this.startAngle) ?
                    this.endAngle - this.startAngle : this.endAngle - this.startAngle + Flatten.PIx2;
            } else {
                sweep = Flatten.Utils.GT(this.startAngle, this.endAngle) ?
                    this.startAngle - this.endAngle : this.startAngle - this.endAngle + Flatten.PIx2;
            }

            if ( Flatten.Utils.GT(sweep, Flatten.PIx2) ) {
                sweep -= Flatten.PIx2;
            }
            if ( Flatten.Utils.LT(sweep, 0) ) {
                sweep += Flatten.PIx2;
            }
            return sweep;
        }

        /**
         * Get start point of arc
         * @returns {Point}
         */
        get start() {
            let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);
            return p0.rotate(this.startAngle, this.pc);
        }

        /**
         * Get end point of arc
         * @returns {Point}
         */
        get end() {
            let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);
            return p0.rotate(this.endAngle, this.pc);
        }

        /**
         * Get arc length
         * @returns {number}
         */
        get length() {
            return Math.abs(this.sweep*this.r);
        }

        /**
         * Get bounding box of the arc
         * @returns {Box}
         */
        get box() {
            let func_arcs = this.breakToFunctional();
            let box = func_arcs.reduce( (acc, arc) => acc.merge(arc.start.box), new Flatten.Box() );
            box = box.merge(this.end.box);
            return box;
        }

        /**
         * Get bounding box of arc
         * @returns {Box}
         */
        oldbox() {
            let xs,ys,xe,ye;
            let dxs,dys,dxe,dye;
            let xmin,ymin,xmax,ymax;
            let quads, quade, quad;
            let xc = this.pc.x;
            let yc = this.pc.y;
            let r = this.r;

            let ps = this.start;
            let pe = this.end;

            let box = new Flatten.Box();

            /* order (xs, xe) and (ys, ye) always clockwise */
            if(this.counterClockwise){
                xs = pe.x ; ys = pe.y ;
                xe = ps.x ; ye = ps.y ;
            } else {
                xs = ps.x ; ys =ps.y ;
                xe = pe.x ; ye = pe.y ;
            }
            dxs = xs-xc ; dys = ys-yc ;
            dxe = xe-xc ; dye = ye-yc ;

            xmin = xc-r ; ymin = yc-r ;
            xmax = xc+r ; ymax = yc+r ;

            xmin = Math.min(xmin,xs) ; xmin = Math.min(xmin,xe);
            xmax = Math.max(xmax,xs) ; xmax = Math.max(xmax,xe);
            ymin = Math.min(ymin,ys) ; ymin = Math.min(ymin,ye);
            ymax = Math.max(ymax,ys) ; ymax = Math.max(ymax,ye);

            /* Calculate the quadrant for each point */
            /*
             *           |
             *         1 | 0
             *       ----------
             *         2 | 3
             *           |
             */
            quads = (dxs >= 0 ? (dys >= 0 ? 0 : 3) : (dys >= 0 ? 1 : 2));
            quade = (dxe >= 0 ? (dye >= 0 ? 0 : 3) : (dye >= 0 ? 1 : 2));

            /* There are 16 combinations of start-end configurations */
            /* The more complex ones are when both points are in the
             * same quadrant (They require additional conditions).
             * Remember that we converted everything to clockwise !
             */

            quad = (quads &lt;&lt; 2) + quade ;

            switch(quad){
                case 0 :
                    /* From quadrant 0 to 0 */
                    if(xs &lt; xe || ys > ye){
                        box.set(xs,ye,xe,ys);
                    } else {
                        box.set(xmin,ymin,xmax,ymax);
                    }
                    break ;
                case 1 :
                    /* From quadrant 0 to 1 */
                    box.set(xmin,ymin,xmax,Math.max(ys,ye));
                    break ;
                case 2 :
                    /* From quadrant 0 to 2 */
                    box.set(xe,ymin,xmax,ys);
                    break ;
                case 3 :
                    /* From quadrant 0 to 3 */
                    box.set(Math.min(xs,xe),ye,xmax,ys);
                    break ;
                case 4 :
                    /* From quadrant 1 to 0 */
                    box.set(xs,Math.min(ys,ye),xe,ymax);
                    break ;
                case 5 :
                    /* From quadrant 1 to 1 */
                    if(xs &lt; xe || ys &lt; ye){
                        box.set(xs,ys,xe,ye);
                    } else {
                        box.set(xmin,ymin,xmax,ymax);
                    }
                    break ;
                case 6 :
                    /* From quadrant 1 to 2 */
                    box.set(Math.min(xs,xe),ymin,xmax,ymax);
                    break ;
                case 7 :
                    /* From quadrant 1 to 3 */
                    box.set(xs,ye,xmax,ymax);
                    break ;
                case 8 :
                    /* From quadrant 2 to 0 */
                    box.set(xmin,ys,xe,ymax);
                    break ;
                case 9 :
                    /* From quadrant 2 to 1 */
                    box.set(xmin,ys,Math.max(xs,xe),ye);
                    break ;
                case 10 :
                    /* From quadrant 2 to 2 */
                    if(xs > xe || ys &lt; ye){
                        box.set(xe,ys,xs,ye);
                    } else {
                        box.set(xmin,ymin,xmax,ymax);
                    }
                    break ;
                case 11 :
                    /* From quadrant 2 to 3 */
                    box.set(xmin,Math.min(ys,ye),xmax,ymax);
                    break ;
                case 12 :
                    /* From quadrant 3 to 0 */
                    box.set(xmin,ymin,Math.max(xs,xe),ymax);
                    break ;
                case 13 :
                    /* From quadrant 3 to 1 */
                    box.set(xmin,ymin,xs,ye);
                    break ;
                case 14 :
                    /* From quadrant 3 to 2 */
                    box.set(xe,ymin,xs,Math.max(ys,ye));
                    break ;
                case 15 :
                    /* From quadrant 3 to 3 */
                    if(xs > xe || ys > ye){
                        box.set(xe,ye,xs,ys);
                    } else {
                        box.set(xmin,ymin,xmax,ymax);
                    }
                    break ;
            }
            return box;
        }

        /**
         * Returns true if arc contains point
         * @param {Point} pt - point to test
         * @returns {boolean}
         */
        contains(pt) {
            // first check if  point on circle (pc,r)
            if (!Flatten.Utils.EQ(this.pc.distanceTo(pt), this.r))
                return false;

            // point on circle

            if (pt.equalTo(this.start))
                return true;

            let angle = new Flatten.Vector(this.pc, pt).slope;
            let test_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise);
            return Flatten.Utils.LE(test_arc.length, this.length);
        }

        /**
         * Returns array of intersection points between arc and other shape
         * @param shape
         * @returns {*}
         */
        intersect(shape) {
            if (shape instanceof Flatten.Line) {
                return shape.intersect(this);
            }
            if (shape instanceof Flatten.Circle) {
                return Arc.intersectArc2Circle(this, shape);
            }
            if (shape instanceof Flatten.Segment) {
                return shape.intersect(this);
            }
            if (shape instanceof Flatten.Arc) {
                return Arc.intersectArc2Arc(this, shape);
            }
        }

        distanceToPoint(pt) {
            let circle = new Flatten.Circle(this.pc, this.r);
            let distToCircle = pt.distanceTo(circle);
            let distToStart = pt.distanceTo(this.start);
            let distToEnd = pt.distanceTo(this.end);
            return Math.min(distToCircle, Math.min(distToStart, distToEnd));
        }

        /**
         * Returns array of sub-arcs broken in extreme point 0, pi/2, pi, 3*pi/2
         * @returns {Array}
         */
        breakToFunctional() {
            let func_arcs_array = [];
            let angles = [0, Math.PI/2, 2*Math.PI/2, 3*Math.PI/2];
            let pts = [
                this.pc.translate(this.r,0),
                this.pc.translate(0,this.r),
                this.pc.translate(-this.r,0),
                this.pc.translate(0,-this.r)
            ];

            // If arc contains extreme point,
            // create test arc started at start point and ended at this extreme point
            let test_arcs = [];
            for (let i=0; i &lt; 4; i++) {
                if (pts[i].on(this)) {
                    test_arcs.push(new Flatten.Arc(this.pc, this.r, this.startAngle, angles[i], this.counterClockwise));
                }
            }

            if (test_arcs.length == 0) {                  // arc does contain any extreme point
                func_arcs_array.push(this.clone());
            }
            else {                                        // arc passes extreme point
                // sort these arcs by length
                test_arcs.sort((arc1, arc2) => arc1.length - arc2.length);

                for (let i = 0; i &lt; test_arcs.length; i++) {
                    let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;
                    let new_arc;
                    if (prev_arc) {
                        new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, test_arcs[i].endAngle, this.counterClockwise);
                    }
                    else {
                        new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, test_arcs[i].endAngle, this.counterClockwise);
                    }
                    if (!Flatten.Utils.EQ_0(new_arc.length)) {
                        func_arcs_array.push(new_arc.clone());
                    }
                }

                // add last sub arc
                let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;
                let new_arc;
                if (prev_arc) {
                    new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, this.endAngle, this.counterClockwise);
                }
                else {
                    new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, this.endAngle, this.counterClockwise);
                }
                if (!Flatten.Utils.EQ_0(new_arc.length)) {
                    func_arcs_array.push(new_arc.clone());
                }
            }
            return func_arcs_array;
        }

        /**
         * Return tangent unit vector in the start point in the direction from start to end
         * @returns {Vector} - tangent vector in start point
         */
        tangentInStart() {
            let vec = new Flatten.Vector(this.pc, this.start);
            let angle = this.counterClockwise ? Math.PI/2. : -Math.PI/2.;
            let tangent = vec.rotate(angle).normalize();
            return tangent;
        }

        /**
         * Return tangent unit vector in the end point in the direction from end to start
         * @returns {Vector} - tangent vector in end point
         */
        tangentInEnd() {
            let vec = new Flatten.Vector(this.pc, this.end);
            let angle = this.counterClockwise ? -Math.PI/2. : Math.PI/2.;
            let tangent = vec.rotate(angle).normalize();
            return tangent;
        }

        static intersectArc2Arc(arc1, arc2) {
            var ip = [];

            if (arc1.box.notIntersect(arc2.box)) {
                return ip;
            }

            // Special case: overlapping arcs
            // May return up to 4 intersection points
            if (arc1.pc.equalTo(arc2.pc) &amp;&amp; Flatten.Utils.EQ(arc1.r, arc2.r)) {
                let pt;

                pt = arc1.start;
                if (pt.on(arc2))
                    ip.push(pt);

                pt = arc1.end;
                if (pt.on(arc2))
                    ip.push(pt);

                pt = arc2.start;
                if (pt.on(arc1)) ip.push(pt);

                pt = arc2.end;
                if (pt.on(arc1)) ip.push(pt);

                return ip;
            }

            // Common case
            let circle1 = new Flatten.Circle(arc1.pc, arc1.r);
            let circle2 = new Flatten.Circle(arc2.pc, arc2.r);
            let ip_tmp =  circle1.intersect(circle2);
            for (let pt of ip_tmp) {
                if (pt.on(arc1) &amp;&amp; pt.on(arc2)) {
                    ip.push(pt);
                }
            }
            return ip;
        }

        static intersectArc2Circle(arc, circle) {
            let ip = [];

            if (arc.box.notIntersect(circle.box)) {
                return ip;
            }

            // Case when arc center incident to circle center
            // Return arc's end points as 2 intersection points
            if (circle.pc.equalTo(arc.pc) &amp;&amp; Flatten.Utils.EQ(circle.r, arc.r)) {
                ip.push(arc.start);
                ip.push(arc.end);
                return ip;
            }

            // Common case
            let circle1 = circle;
            let circle2 = new Flatten.Circle(arc.pc, arc.r);
            let ip_tmp = circle1.intersect(circle2);
            for (let pt of ip_tmp) {
                if (pt.on(arc)) {
                    ip.push(pt);
                }
            }
            return ip;
        }

        definiteIntegral(ymin=0) {
            let f_arcs = this.breakToFunctional();
            let area = f_arcs.reduce( (acc, arc) => acc + arc.circularSegmentDefiniteIntegral(ymin), 0.0 );
            return area;
        }

        circularSegmentDefiniteIntegral(ymin) {
            let line = new Flatten.Line(this.start, this.end);
            let onLeftSide = this.pc.leftTo(line);
            let segment = new Flatten.Segment(this.start, this.end);
            let areaTrapez = segment.definiteIntegral(ymin);
            let areaCircularSegment = this.circularSegmentArea();
            let area = onLeftSide ? areaTrapez - areaCircularSegment : areaTrapez + areaCircularSegment;
            return area;
        }

        circularSegmentArea() {
            return (0.5*this.r*this.r*(this.sweep - Math.sin(this.sweep)))
        }

        /**
         * Return string to draw arc in svg
         * @param attrs - json structure with any attributes allowed to svg path element,
         * like "stroke", "strokeWidth", "fill"
         * Defaults are stroke:"black", strokeWidth:"3", fill:"none"
         * @returns {string}
         */
        svg(attrs = {stroke:"black", strokeWidth:"3", fill:"none"}) {
            let largeArcFlag = this.sweep &lt;= Math.PI ? "0" : "1";
            let sweepFlag = this.counterClockwise ? "1" : "0";
            let {stroke, strokeWidth, fill} = attrs;

            if (Flatten.Utils.EQ(this.sweep, 2*Math.PI)) {
                let circle = new Flatten.Circle(this.pc, this.r);
                return circle.svg(attrs);
            }
            else {
                return `\n&lt;path d="M${this.start.x},${this.start.y}
                             A${this.r},${this.r} 0 ${largeArcFlag},${sweepFlag} ${this.end.x},${this.end.y}"
                    stroke="${stroke}" stroke-width="${strokeWidth}" fill="${fill}"/>`
            }
        }
    };

    /**
     * Function to create arc equivalent to "new" constructor
     * @param args
     */
    Flatten.arc = (...args) => new Flatten.Arc(...args);
};</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Wed Sep 06 2017 01:06:56 GMT+0300 (Jerusalem Daylight Time) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
